
# 数组面试题

        笔试和面试中，除了字符串，另一类出现频率极高的问题便是与数组相关的问题。
        解题思路：
        先一般考虑“万能的”暴力穷举（递归、回溯），如求n个数的全排列或八皇后（N皇后问题）。
        但因为穷举时间复杂度通常过高，所以需要考虑更好的方法。

        如   分治法（通过分而治之，然后归并）；

        以及 空间换时间（如活用哈希表）。

        此外，选择合适的 数据结构 可以显著提升效率，如寻找最小的k个数中，用 堆 代替 数组，也可借鉴快排思想，中枢分区方法。

        再有，如果题目允许排序，则可以考虑  排序。

        寻找和为定值的两个数中，先排序，然后用 前后两个指针 往中间扫描。

        而如果如果已经排好序了（如杨氏矩阵查找中），则想想有无必要二分，二分法。

        但是，如果题目不允许排序呢？这个时候，

        我们可以考虑 不改变数列顺序的 贪心算法（如 最小生成树Prim、Kruskal 及 最短路dijkstra）

        或 动态规划（如 01背包问题，每一步都在决策）。

        最后，注意细节处理，不要忽略边界条件，如字符串转换成整数。
        
## 第一题 寻找集合中的最小的K个数
        输入n个整数，输出其中最小的k个。
### 解法1 先排序再选择
        要求一个序列中最小的k个数，按照惯有的思维方式，
        则是先对这个序列从小到大排序，
        然后输出前面的最小的k个数。
        至于选取什么的排序方法，我想你可能会第一时间想到快速排序
        我们知道，快速排序平均所费时间为n*logn，
        然后再遍历序列中前k个元素输出即可。
        因此，总的时间复杂度：O（n * log n)+O(k)=O（n * log n）。
### 解法2 选择排序思想
        解法二

        咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。
        既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：
        
        1、遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；
        
        2、对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））；
        
        3、继续遍历剩余n-k个数。
           假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果x < kmax ，用x替换kmax，
           并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组，直到，k个数是此时最小的
           
        每次遍历，更新或不更新数组的所用的时间为O（k）或O（0）。故整趟下来，时间复杂度为n*O（k）=O（n*k）。  
### 解法3 利用最大堆 作为容器

        更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：
        
        1、用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；
        
        2、堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
        
        3、遍历剩余n-k个数。
          假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：
          如果x < kmax，用x替换kmax，然后更新堆（用时logk）；
          否则不更新堆。
        这样下来，总的时间复杂度:O（k+（n-k）*logk）=O（n*logk）。
        此方法得益于堆中进行查找和更新的时间复杂度均为：O(logk)
        （若使用解法二：在数组中找出最大元素，时间复杂度：O（k））。  
        
### 解法4 利用快排思想 得到大小数的 分区中枢
        int Cut(int a[], int low, int high){
          int temp = a[low];// 区间第一个元素 可以随机选择 在替换到low的位置
          while(low < high){
            while((low < higt)&&(a[high] > temp)) --high;// 从右边向左寻找比 temp小的元素 a[higt]
            a[low] = a[high];// 把比temp小的元素 放在 原来temp的位置(左边小的区域)
            while((low < high)&&(a[low] < temp))  ++low;// 从左边寻找比 temp大的元素a[low] 放在右边 high的位置
            a[high] = a[low];
           }
          a[low] = temp; // 临时变量 放在 中枢位置
          return low;    // 返回中枢位置
        }

        // 在数组a中选择k个最小的元素  块选  非递归调用
        void QuickSelest(int a[], int low, int high, int k){
          int index =  Cut(a, 0, n-1);// 首先得到一个中枢
          while(index != k-1){// 非递归调用
          if(index > k - 1) index = Cut(a, low, index -1);// 左半部分小的元素个数大于k 在左半部分找 中枢
          else              index = Cut(a, index+1, high);// 左半部分小的元素个数小于k 右半部分还有，在右半部分找 中枢
          }
         // 打印
         for(int i = 0; i<k; ++i) cout<<a[i];
         cout << endl;
        }

        // 而快排为   是递归调用
        void QuickSort(int a[], int low, int high){
          int index;
          if(low < high){
            index = Cut(a, low, high);//选取中枢位置
            QuickSort(a, low, index-1);//对左边快排
            QuickSort(a, index+1, high);//对右边快排
          }
        }

        // 二分查找   非递归版本
        int BinarySearch(int a[], int low, int high, int key){
        int mid;//中间元素
        while(low < high){
        int mid = low + ((high - low)>>1);//中间元素的 下标 在循环体内 不停的被改变
        if( key < a[mid] )     high = mid - 1;// 查找的元素小于中值  高区间移至 mid-1
        elae if(key > a[mid] ) low  = mid + 1;// 查找元素大于中值， 将低区间移至 mid+1
        else return mid;
        }
        return -1;//未找打 返回-1
        }

        // 二分查找   递归版本
        int BinarySearch(int a[], int low, int higt, int key){
        int mid = low + ((high - low)>>1);//中间元素的 下标
        if(low < high){
          if(key < a[mid])      return BinarySearch(a, low, mid-1, key);
          else if(key > a[mid]) return BinarySearch(a, mid+1, high, key);
          else return mid;
        }
        return -1;
        }
        
## 第二题 寻找和为定值的两个数
        输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。
        要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，输出任意一对即可。
        例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。
        思路：暴力搜索 时间复杂度 n^2
        其二，二分法（相当于用两个指针），从前后向中间搜索，看情况移动左右指针
        
> 代码如下

        // 二分（若无序，先排序后二分），时间复杂度总为O(N log N)，空间复杂度为O（1）；
        void findTwo2(int a[], int low, int high, int sum){
         //sort(a, a+high+1);   如果数组非有序的，那就事先排好序O(N log N)
                 while(low < high){
                        if(a[low] + a[high] > sum)      --high;//太大 right减少
                        else if(a[low] + a[high] < sum) ++low; //太小 low增加
                        else cout << a[low] << a[high] < endl;
                 }
                cout << "Can't found" < endl;
        }
> 总结 

        不论原序列是有序还是无序，解决这类题有以下三种办法：
        1、二分（若无序，先排序后二分），时间复杂度总为O(N log N)，空间复杂度为O（1）；
        2、扫描一遍X-S[i] 映射到一个数组或构造hash表，时间复杂度为O(N)，空间复杂度为O(N)；
        3、两个指针两端扫描（若无序，先排序后扫描），时间复杂度最后为：
           有序O(N)，无序O(N log N + N)=O(N log N)，空间复杂度都为O(1)。
        所以，要想达到时间O(N)，空间O(1)的目标，除非原数组是有序的（指针扫描法），
        不然，当数组无序的话，就只能先排序，后指针扫描法或二分（时间 O(Nlog N)，空间O(1)），
        或映射或hash（时间O(N)，空间O(N)）。时间或空间，必须牺牲一个，达到平衡。
        综上，若是数组有序的情况下，优先考虑两个指针两端扫描法，以达到最佳的时O(N)，空O(1)效应。
        否则，如果要排序的话，时间复杂度最快当然是只能达到O(N log N)，空间O(1)则不在话下。
### 举一反三：
        输入：int[]nums int target 
        输出：符合要求的所有情况 
        给定一个int类型的数组，sum2、sum3、sum4分别输出2、3、4个元素的和为target的所有结果，不能重复，并且结果从小到大排序。
        【解法】： 
        三个题目均可以使用双指针的做法。首先对原始数组进行排序，排序的意义为：
        （1）保证最后结果的有序性；
        （2）从小到大的查找是否满足target，
        若小于他，则start指针往前走 ++start，
        若大于他，这end指针往回走 --end； 
        接着第一个指针从最小的元素开始，
        第二个指针从最大的元素开始，通过对和与target进行比较，判断start和end的走向。 
        sum2可以不用循环，只需要两个指针。
        同时sum2还可以有另一种解法，从左到右判断，采用一个集合保存判断过的结果，从集合中查找target-nums[i]是否存在；（n） 
        sum3采用一层循环，start从循环处的下一个元素开始（n`2）
        sum4采用两层循环，第二层循环从第一层循环的i值开始，最内部start从第二层循环的下一个元素开始。(n`3) 
        
### 寻找和为定值的多个数
        题目描述
        输入两个整数n和sum，从数列1，2，3.......n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。
> 01背包问题求解

        解法一
        注意到取n，和不取n个区别即可，考虑是否取第n个数的策略，可以转化为一个只和前n-1个数相关的问题。
        如果取第n个数，那么问题就转化为“取前n-1个数使得它们的和为sum-n”，对应的代码语句就是sumOfkNumber(sum - n, n - 1)；
        如果不取第n个数，那么问题就转化为“取前n-1个数使得他们的和为sum”，对应的代码语句为sumOfkNumber(sum, n - 1)。

        0-1背包问题
        0-1背包问题是最基础的背包问题，其具体描述为：
        有N件物品和一个容量为V的背包。放入第i件物品耗费的费用是Ci，得到的价值是Wi。
        求解将哪些物品装入背包可使价值总和最大。
        简单分析下：这是最基础的背包问题，特点是每种物品仅有一件，可以选择放或不放。
        用子问题定义状态：即F[i, v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
        F[i, v] = max{F[i-1, v], F[i-1, v-Ci ] + Wi}
        根据前面的分析，我们不难理解这个方程的意义：
        “将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），
        那么就可以转化为一个只和前 i-1 件物品相关的问题。
        即：
        如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为 F[i-1, v ]；
        如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-Ci的背包中”，
        此时能获得的最大价值就是F[i-1, v-Ci]再加上通过放入第i件物品获得的价值Wi。

        list<int>list1;
        void SumOfkNumber(int sum, int n)
        {
            // 递归出口
            if (n <= 0 || sum <= 0)
                return;
            // 输出找到的结果
            if (sum == n)
            {
                // 反转list
                list1.reverse();
                for (list<int>::iterator iter = list1.begin(); iter != list1.end(); iter++)
                    cout << *iter << " + ";
                cout << n << endl;
                list1.reverse()//此处还需反转回来
            }
            list1.push_front(n); //放置进背包 当前占了n 前面剩余sum-n空间  典型的01背包问题
            SumOfkNumber(sum - n, n - 1);//“放”n，前n-1个数“填满”sum-n

            list1.pop_front();// 取出来 不放进去 前面还剩余sum的空间
            SumOfkNumber(sum, n - 1); //不“放”n，n-1个数“填满”sum
        }



