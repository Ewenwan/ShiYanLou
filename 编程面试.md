
# 数据结构

## 字符串

### 1 旋转字符串
给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。
#### 解法1.1 暴力移位法          将字符一个一个的移动到尾部 或头部
      // 左边的第一个字符移动到最右边
      void LeftShiftOne(char* s, int n)
      {
        char tep = s[0];    // 保存左边的第一个字符 tep
        for (int i = 1; i < n; ++i)
         {
            s[i - 1] = s[i];// 从前向后 靠右的字符 依次向左移动1位
         }
        s[n - 1] = tep;     // tep 放入最右边的位置
      }
      // 右边的第一个字符移动到 最左边
      void RightShiftOne(char* s, int n)
      {
         char tep = s[n - 1];// 保存右边的最后一个字符 tep
         for(int  i = n-1; i > 0; --i)
         {
            s[i] = s[i - 1]; // 从后向前 靠左的字符 依次向右 移动1位
         }
         s[0] = tep;         // tep 放入最左边的位置
      }

> 因此，若要把字符串开头的m个字符移动到字符串的尾部，则可以如下操作：

    void LeftRotateSring(char *s, int n, int m)
    {
        while(m--)
        {
             LeftShiftOne(s, n);// 每次移动一个字符 一共 移动 m次
        }
    }
> 而，若要把字符串尾部的m个字符移动到字符串的头部，则可以如下操作：

    void ReftRotateSring(char *s, int n, int m)
    {
        while(m--)
        {
             ReftShiftOne(s, n);// 每次移动一个字符 一共 移动 m次
        }
    }
> 针对长度为n的字符串来说，假设需要移动m个字符到字符串的尾部，对每个字符需要进行移动n次，那么总共需要 mn 次操作，同时设立一个变量保存第一个字符，如此，时间复杂度为O(m n)，空间复杂度为O(1)，空间复杂度符合题目要求，但时间复杂度不符合，所以，我们得需要寻找其他更好的办法来降低时间复杂度。
#### 解法1.2：三步反转法
      对于这个问题，换一个角度思考一下。
      将一个字符串XY分成X(m个字符)和Y(n-m个字符)两个部分，在每部分字符串上定义反转操作，
      如X^T，即把X的所有字符反转（如，X="abc"，那么X^T="cba"），那么就得到下面的结论：
      (X^TY^T)^T=YX，显然就解决了字符串的反转问题。
      例如，字符串 abcdef ，若要让def翻转到abc的前头，只要按照下述3个步骤操作即可：
      1.首先将原字符串分为两个部分，即X:abc，Y:def；
      2.将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
      3.反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。

> 三个步骤中后两个步骤都用到了 反转一个字符串

      void ReverseString(char *s, int form, int to)
      {
            while(from < to)// 从首尾开始交换首位位置的值，直到相遇
            {
                  char tep  = s[from];// 保存左边
                  s[from++] = s[to];  //右边 交换给左边 同时左边向右移动一个位置
                  s[to--]   = tep;    // 前右边保存的值 交换给左边 同时 右边向左移动一个位置
            }
      }
      
      // 前 m 后 放在尾部
      // 反转[0..m - 1] 反转[m..n - 1] 反转[0..n - 1]
      void LeftRotateString(char* s, int n, int m)
      {
      m  %= n;// 避免左移数量大于n的情况
      ReverseString(s, 0, m - 1);// 反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba
      ReverseString(s, m, n - 1);// 反转[m..n - 1]，例如Y->Y^T，即 def->fed
      ReverseString(s, 0, n - 1);// 反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。
      }
      // 后m个 放在 头部 
      // 反转[0..n - m - 1] 反转[n - m..n - 1] 反转[0..n - 1]
      void LeftRotateString(char* s, int n, int m)
      {
      m  %= n;// 避免左移数量大于n的情况
      ReverseString(s, 0, n - m - 1);// 反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba
      ReverseString(s, n - m, n - 1);// 反转[n - m..n - 1]，例如Y->Y^T，即 def->fed
      ReverseString(s, 0, n - 1);// 反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。
      }

#### 序列反转 举一反三
      1、链表翻转。给出一个链表和一个数k，比如，链表为1→2→3→4→5→6，
      k=2，则翻转后2→1→6→5→4→3，
      若k=3，翻转后3→2→1→6→5→4，
      若k=4，翻转后4→3→2→1→6→5，用程序实现。
      注解：原序列 XY 则反转后的序列为 X^T Y^T

      2、单词翻转。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变，句子中单词以空格符隔开。
      为简单起见，标点符号和普通字母一样处理。例如，输入“I am a student.”，则输出“student. a am I”。
      注解：先将整个字符串反转，在将其中每个单词反转回来
      
      void Reverse_word(char *str)      
      {      
          if(str == NULL)// 空指针 返回 
              return;      
          int len = strlen(str);// 字符串长度
          // 反转整个字符串
          ReverseString(str, 0, len - 1);    
          int s = 0;//每个单词的 起始 index
          int e = 0;// 每个单词的 后 index
          for(int i = 0; i < len; i++) // 遍历字符串 查找每一个单词
          {       
              e = i;      
              if(str[e] == ' ')// 此处 遇到空格 
              {      
                  ReverseString(str, s, e-1); // 反转这个单词 
                  s = e+1;// 更新 单词的起始指针 
              }      
          }    
          ReverseString(str, s, len - 1);  // 反转最后一个单词 因为最后一个单词后面无空格
      }  







