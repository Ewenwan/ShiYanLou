# VectorCAST软件自动化测试方案

[VectorCAST软件自动化测试方案 博客园](https://www.cnblogs.com/trinitytec/p/4563523.html)

![](https://images2015.cnblogs.com/blog/772469/201510/772469-20151009121947924-361996838.jpg)


VectorCAST™ 是主要用于对C/C++/Ada程序进行软件自动化测试，并能够在Windows和Linux等多种开发环境下运行。其主要功能包含自动化的单元测试、集 成测试、覆盖率分析、回归测试、代码静态分析和测试需求跟踪，它最大特点或相比于其它相关同类工具最大的优势，就在于能够实现最大程度的自动化而且更适用 于嵌入式环境。以下分别予以阐述：

## 单元测试

VectorCAST 会根据被测代码和开发环境自动构建测试套件（Test Harness），在此基础上用户可以根据需要自动地生成或添加测试用例，并灵活地配置以实现不同的测试需求。自动生成的架构中包括：被测对象、测试驱动、桩函数和依赖条件。

### 1. 自动生成测试用例

VectorCAST 支持用户以多种形式的输入输出参数自动地生成测试用例，不需要用户编写测试代码，完全通过 **鼠标和输入窗口** 即可自动完成：

    最大值、最小值和中间值
    二进制、十进制、八进制和十六进制数值
    输入参数范围
    多个参数自动排列组合及配对
    等价类划分
    输入值列表
    期望输出值列表
    期望值容错误差范围
    从外部数据源，如xlc, csv 等，中导入测试用例参数

#### 覆盖率

VectorCAST 可以根据不同的覆盖率的算法分析测程序逻辑，自动地生成满足不同覆盖率要求的测试用例，以尽可能地达到覆盖率要求。对于未能覆盖的部分，用户可以根据工具 提供的逻辑分析报告，如基本路基逻辑和MC/DC 等价类矩阵，用户按照分析结果提示的参数条件额外添加少量测试用例即可达到100%的覆盖率。

    基本路径覆盖 — 自动生成用例通常可以自动达到90%～100%的覆盖率
    MC/DC覆盖 — 自动生成用例覆盖率视测代码实际情况而定

#### 桩函数

被测函数所调用的其它函数可以通过形式被执行，被调函数本身或桩函数。从全部调用实际函数到全部由桩函数替代，用户可以根据自己需要灵活设定需要打桩的对象。VectorCAST 可以支持添加不同输入输出的桩函数，简单的如int, float, double, char 等基本类型变量，也可以支持非常复杂的结构或对象变量。重要的是，这些桩函数基本都只需GUI 操作即可完成，一般不需要人工编写测试代码。


### 2. 测试用例的执行

VectorCAST 对测试用例的执行方式采用真正的数据驱动方式（Data-Driven），所谓数据驱动，就是指测试用例数据只有在测试用例执行的时候才会被读取，而不会随测试代码、桩函数和测试驱动等等一起构建到最终的执行程序中。这样的好处是：

    1）构建和执行速度快；
    2）当被测对象未变动的情况下，对测试用例的输入输出参数进行修改，测试用例不需要重新编译构建。
    
### 3.测试结果验证

测试用例执行完之后，VectorCAST 除了能对被测单元的实际return 值进行断言以外，包括简单类型和覆盖结构体，还可以对它依赖关系中的变量结果值或其成员变量进行验证，报告True或False 断言结果。


### 4. 复杂度分析

测试用例执行结束之后，VectorCAST 会统计相关程序的 **圈复杂度**，并自动生成报告。


### 5. 测试报告

测试结束后，VectorCAST 自动生成详细的测试报告，包括所有测试用例、测试用例输入输出数据、断言结果、程序度量分析结果、不同覆盖率报告和MC/DC 等价类分析矩阵。



##  概述

传统的开发模式（比如：瀑布式开发、V模式开发、较小程度的敏捷开发）由不同阶段组成。最先进行持续集成工作的应该是编码阶段，在该阶段，开发人员根据分派给自己的任务来编写代码。随着开发的不断进行，开发人员很可能要对存储库进行修改，但是他们只是更新自己开发的代码，不会同时更新其它开发人员的修改。所以，在所有的代码都开发完成之后，会有一个特别的集成阶段，将所有开发人员对代码所作的修改进行整合，以形成一个可测试的软件构建。

我们可以估算出该阶段的开始时间（根据对每项任务的判断进行估算），但是很难预测出截止日期，也就是说很难知道完成集成工作需要花费多长时间。开发人员编写的代码可能会相互冲突：每个开发人员编写的代码在独立运行时，也许能够运行得非常好，但是当该代码和其他开发人员的代码结合在一起时，可能就会发现它不能与其它开发人员对代码所作的修改相兼容。这种冲突必须要解决 —— 通常情况下，这都需要手动解决（也有工具可以帮忙），然后还必须重构代码。但是，代码重构过程中也可能会引进更多的矛盾，这样集成工作就会陷入不断重复的状态。

集成是一项非常重要的工作，在极端情况下，解决冲突所耗的精力要远远超乎一开始编写代码时所花费的精力。

这些可能出现的冲突和由此产生的工作量是开发人员不愿意更新存储库中的局部代码的原因之一：更新可能会破坏现在可以正常运行的代码构建。有些问题可能是其他开发人员的代码引起的，所以开发人员就不想花时间去解决这些由其他人的代码引进的问题。

有好多种解决代码冲突的方法。其中一种方法就是改善开发步骤：每次只允许一个开发人员对存储库进行修改。对存储库中的代码进行更新之后，要立刻解决所有的新问题，这样开发人员要做的就不仅仅只是提交代码那么简单了。这种方法可以避免冲突，但是代价很高。开发人员在提交代码的时候，必须保证只有他一个人可以访问这个存储库：在该开发人员解决好所有冲突之前，不能够有任何其它代码提交进来。（否则，所有的提交工作都要重新开始。）这种排外的访问限制有很大的瓶颈，而且很难实行：有些公司甚至利用实体对象来提示是否允许提交：如果桌子上没有该实物就不可以提交。如果团队比较大，不是只有几个开发人员，那么该方法就很难实施，如果团队分布在不同地区，那么这种方法就更不可行了。

完成集成之后就会生成供测试阶段使用的可执行程序——可能会有很多测试阶段——比如，编码规范合规检查，单元测试，集成测试，系统测试，覆盖率测试，验收测试，部署测试等。在各个测试阶段，如果测试失败，表示代码需要重新编写、重新集成，并且重新测试。这样会有一个潜在的问题，就是开发人员在编写代码时所花费的时间与重写代码时所花费的时间不同：这两者之间的时间差越大，开发人员重新熟悉这些代码的难度越大，因而修改阶段的工作量也会大大增加。

问题的根源在于对开发阶段的划分。软件的编写不是一个单向过程：不是集成工作一开始，编码工作就结束了。虽然将开发任务划分给可以平行地开展工作的开发人员相对而言比较简单，但是集成往往是系列性的，所以要将集成工作同时分配给多个开发人员就比较困难了。


> 解决方案

正如持续集成所推崇的那样，这个解决方案的部分内容就是用一系列小阶段（如图1）取代传统的编码测试、单元测试、集成测试、系统测试和验收环节。每个小阶段都包含编码测试、单元测试、集成测试、系统测试和验收环节——开发人员每次对存储库进行修改时都要执行这些步骤。每次更改之后都要对代码进行集成、测试和验证，代码每通过一项测试，其质量就越接近于可发布版本.

将集成工作扩展到整个开发阶段意味着繁重的集成工作被分割成了一个个更小、更易操作的任务。当问题能够尽早被发现并独立解决时，就不会得到恶化，因而就不可能形成严重的集成问题——所谓的“集成地狱”。这就是持续集成。可以将这个过程视为从瀑布式向V模型开发模式发展，从敏捷开发向持续集成发展。

这种方法只有在大多数测试过程和任务都可进行实现自动化操作的情况下才可行。因为如果每次存储库中有增量提交时，都要手动完成那些任务，很明显是不可行。

提交之前要进行测试

持续集成模式存在的一个问题就是，它无法防止不能运行的、坏的或不兼容的代码进入存储库中：这种模式只能做到在这类代码提交之后，立刻发现它们。开发人员在处理及修复这类代码造成的问题时，必须严格遵守规则。

在提交之前对代码进行测试的做法是为了保证只有正常的、可运行的、经过测试的代码才被提交到核心存储库中（存储待发布代码的库），因此，这一做法也是实现持续交付的关键所在。这一概念就是说，只有能够发布的代码才能进入存储库中——所以，在提交代码之前，必须对代码进行全面测试。虽然有很多方法可以帮助实现这一目标，但是最常见的做法就是保证未经测试的代码绝不会进入核心存储库。另一个方法就是同时使用临时存储库和核心存储库：在这里只是简单介绍一下这种方法，本文一直会提到这种方法。

当开发人员向存储库中提交代码时，代码不会自动提交到正式存储库，而是会到临时库中。这种做法对于开发人员来说很容易理解：他们提交代码时，和向正式存储库中提交代码一样。持续集成服务器会从临时库中检测到新提交的代码，然后构建并测试这些代码。如果这些代码能够通过所有的测试，那么本次提交就会被转移到正式存储库中，同时也会附上提交者的名字和日志文件。这个做法对于开发人员来说也很好理解：因为就和他们将代码直接提交到了正式存储库中一样（只是时间上有点滞后）。

如果代码未能通过所有的测试，那么本次提交就会保留在临时库中。开发人员会收到通知：他们可以采取必要的补救措施来修复存在的问题，而此时正式存储库中的代码则保持不变。

这一过程要求所有的测试都能够自动执行，而且定义明确。随着项目的成熟，测试也可能会有所改变：比如，贝塔测试可能主要着眼于基本功能，而对于待发布的代码会有更严格的测试标准，在维护阶段则会更加注重测试新功能。

