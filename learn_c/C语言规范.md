# C语言规范
## 1.头文件
若包含了头文件aa.h，则就引入了新的依赖：一旦aa.h被修改，任何直接和间接包含aa.h代码都会被重新编译。如果aa.h又包含了其他头文件如bb.h，那么bb.h的任何改变都将导致所有包含了aa.h的代码被重新编译，在敏捷开发方式下，代码会被频繁构建，漫长的编译时间将极大的阻碍频繁构建。因此，我们倾向于减少包含头文件，尤其是在头文件中包含头文件，以控制改动代码后的编译时间。

合理的头文件划分体现了系统设计的思想，但是从编程规范的角度看，仍然有一些通用的方法，用来合理规划头文件。

* 原则1.1 头文件中适合放置接口的声明，不适合放置实现。

   说明：头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。

   内部使用的函数（相当于类的私有方法）声明不应放在头文件中。
   
   内部使用的宏、枚举、结构定义不应放入头文件中。
   
   变量定义不应放在头文件中，应放在.c文件中。
   
* 原则1.2 头文件应当职责单一。

   说明：头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件。

* 原则1.3 头文件应向稳定的方向包含。

   产品依赖于平台，平台依赖于标准库。某产品线平台的代码中已经包含了产品的头文件，导致平台无法单独编译、发布和测试，是一个非常糟糕的反例。
   
   除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口，

* 规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。

   说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。

* 规则1.2 禁止头文件循环依赖。

   说明：头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。
   
* 规则1.3 .c/.h文件禁止包含用不到的头文件。

   说明：很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件。
   
* 规则1.4 头文件应当自包含。

   说明：简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。

* 规则1.5 总是编写内部#include保护符（#define 保护）。

   说明：多次包含一个头文件可以通过认真的设计来避免。如果不能做到这一点，就需要采取阻止头文件内容被包含多于一次的机制。
   
   所有头文件都应当使用#define 防止头文件被多重包含，命名格式为FILENAME_H，为了保证唯一性，更好的命名是PROJECTNAME_PATH_FILENAME_H。
   
* 规则1.6 禁止在头文件中定义变量。

   说明：在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。

* 规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。

* 规则1.8 禁止在extern "C"中包含头文件。

   说明：在extern "C"中包含头文件，会导致extern "C"嵌套。
   
* 建议1.1 一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名。  
   
* 建议1.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。

   说明：降低接口使用者的编写难度。  
   
* 建议1.3 头文件不要使用非习惯用法的扩展名，如.inc。

* 建议1.4 同一产品统一包含头文件排列方式。

## 2.函数
函数设计的精髓：编写整洁函数，同时把代码有效组织起来。

* 1.整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。

* 2.代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。


* 原则2.1 一个函数仅完成一件功能。

说明：一个函数实现多个功能给开发、使用、维护都带来很大的困难。
将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。

如 realloc()函数情况太多，容易发生错误。

```c
char *buffer = (char *)malloc(XXX_SIZE);// 分配内存
//.....
buffer = (char *)realloc(buffer, NEW_SIZE);// 重新分配一块内存
// 如果没有足够可用的内存用来完成重新分配，函数返回为NULL，导致buffer原来指向的内存被丢失。
```

* 原则2.2 重复代码应该尽可能提炼成函数。

说明：重复代码提炼成函数可以带来维护成本的降低。






## 3.标识符命名与定义


## 4.变量


## 5.宏 常量

## 6.质量保证

## 7.程序效率

## 8.注释

## 9.排版与格式

## 10.表达式

## 11.代码编辑、编译


## 12.可测性

## 13.安全性

### 字符串操作安全
### 整数安全
### 格式化输出安全
### 文件I/O安全

## 14.单元测试

## 15.可移植性


## 16.业界编程规范






