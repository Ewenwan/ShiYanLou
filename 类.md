# 类的拷贝控制
## 构造函数、拷贝函数 、 赋值函数、析构函数
      class Sales_data{
      public:
        Sales_data() = default;// 默认合成 默认构造函数
        Sales_data(const Sales_data& ) =  default;// 默认合成 拷贝构造函数
        Sales_data& operator=(const Sales_data&);//  拷贝赋值运算符
        ~Sales_data() = default;// 默认合成 默认析构函数
      };
       Sales_data&  Sales_data::operator=(const Sales_data&) = default;//  拷贝赋值运算符 类外定义
 ## 使用 delete 删除函数 避免拷贝
       struct NoCopy(){// struct 默认为 public
       NoCopy() = default;//  默认合成 默认构造函数    不能是删除函数
       NoCopy(const NoCopy&) = delete;// 阻止拷贝
       NoCopy&  operator=(const NoCopy&);//  阻止赋值
       ~NoCopy() = default;// 默认合成 默认析构函数   不能是删除函数
       };

## private 拷贝控制  用户可定义和删除该对象 但不能拷贝它们   不过该类的成员函数 和其 有元函数和有元类 可以 拷贝
      class privateCopy{// class 默认为 private  普通用户无法访问
        privateCopy(const privateCopy&);// 私有拷贝构造函数
        privateCopy& operator=(const privateCopy&);// 私有拷贝赋值运算符
      public:
        privateCopy() = default; // 默认合成  默认构造函数
        ~privateCopy() = default;// 默认合成 默认析构函数   不能是删除函数
      };
      
##  指针 与 拷贝构造函数 和 拷贝赋值运算符
      struct Node{
      char* name;//名字 字符指针
      int age;// 年龄
      Node(char* n = " ", int a = 0 ){//默认构造函数
       name = strdup(n);// strdup()字符串拷贝库函数
       age = a;
       }
       // 拷贝构造函数未定义     编译器自动生成一个(自动生成的 只是逐个对成员复制,遇到指针就会出问题)
       // 拷贝赋值运算符也未定义 编译器自动生成一个(自动生成的 只是逐个对成员复制,遇到指针就会出问题) 
      };

      // 执行拷贝时 指针对象会指向同一个对象
      Node node1("Role", 20), node2(node1);//使用node1 初始化 node2 
      strcpy(node2.name, "Wendy");// 指向了同一个对象
      node2.age = 30;// 非指针正常赋值
      cout << node1.name << " " << node1.age << " " << node2.name << " " << node2.age << endl;
      // Wendy  20  Wendy  30  // 


###  定义 拷贝构造函数 
      struct Node{
      char* name;//名字 字符指针
      int age;// 年龄
      Node(char* n = " ", int a = 0 ){//默认构造函数
       name = strdup(n);// strdup()字符串拷贝库函数
       age = a;
       }
       // 拷贝构造函数
       Node(const Node& n){
       name = strdup(n.name);
       age = n.age;
       }
       // 拷贝赋值运算符也未定义 编译器自动生成一个  (自动生成的 只是逐个对成员复制,遇到指针就会出问题)
      };

      Node node1("Role", 20), node2(node1);//使用node1 初始化 node2  使用拷贝构造函数
      strcpy(node2.name, "Wendy");
      node2.age = 30;// 正常赋值
      cout << node1.name << " " << node1.age << " " << node2.name << " " << node2.age << endl;
      // Role  20  Wendy  30  // 
      
### 定义拷贝赋值运算符  重载 赋值运算符
      struct Node{
      char* name;//名字 字符指针
      int age;// 年龄
      Node(char* n = " ", int a = 0 ){//默认构造函数
       name = strdup(n);// strdup()字符串拷贝库函数
       age = a;
       }
       
       // 拷贝构造函数
       Node(const Node& n){
       name = strdup(n.name);
       age = n.age;
       }
       
       // 拷贝赋值运算符
      Node& operate=(const Node& n){
          if(this != &n){// 确保赋值运算符的两边不是同一个类的同一个对象，避免重复 定义自己
             if(name != 0) free(name);//先释放之前的内存（如果之前已经指向了内存，避免内存泄漏）
             name = strdup(n.name);// 再用 等号 左边的对象初始化 对象
             age = n.age;
            }
          return  *this;// this 起始就是 类对象的地址
          }
      };

### 指针与析构函数  默认的析构函数 只会释放 指针所占据的内存 而不会释放指针指向的内存空间  会造成 内存泄漏
      struct Node{
      char* name;//名字 字符指针
      int age;// 年龄
      Node(char* n = " ", int a = 0 ){//默认构造函数
       name = strdup(n);// strdup()字符串拷贝库函数
       age = a;
       }
       
       // 拷贝构造函数
       Node(const Node& n){
       name = strdup(n.name);
       age = n.age;
       }
       
       // 拷贝赋值运算符
      Node& operate=(const Node& n){
          if(this != &n){// 确保赋值运算符的两边不是同一个类的同一个对象，避免重复 定义自己
             if(name != 0) free(name);//先释放之前的内存（如果之前已经指向了内存，避免内存泄漏）
             name = strdup(n.name);// 再用 等号 左边的对象初始化 对象
             age = n.age;
            }
          return  *this;// this 起始就是 类对象的地址
          }
        // 定义析构函数
       ~Node(){
       if(name != 0) free(name);//指针不为空，就已经使用了指向的内存，需要free手动释放掉
       }
      
      };

## 通过函数返回引用类型  可以改变类内变量的访问方式   破坏了 隐藏域
      class refTest{
            public:
            int& getRefN(){
                  return n;//n为类内私有变量 返回该私有变量引用后 类外就可以访问它
            }
            int getN(){
                  return n;//n为类内私有变量
            }
            private:
                  int n;
      } c;
      //c.n = 6;// 错误  外部直接访问不了 类内私有变量
      int& k = c.getRefN();//通过返回引用 可以间接访问修改  类内私有变量
      k = 7;//  类内私有变量 n 被修改为 7
      cout << c.getN();// 可以看到 n 被修改为 7
      c.getRefN() = 10;//直接通过 c.getRefN() 来给 类内私有变量 n 赋值




# 重载
## 重载输出运算符 <<  为特定类对象 重载输出运算符 返回的是 ostream& 输出流对象的引用
    // 一般定义成 非成员函数 在{};外面
     ostream& operator<<(ostream& os, const Sales_data& item ){
       os << item.isbn() << " " << item.units_sold << " " << item.revenue << " " << item.avg_price();
       // 使用了 字符串的、int、double的 输出运算符 类构成类的 输出运算符
       return os;
     }
## 重载 输入 运算符 >>  返回的是  istream& 输入流对象的引用
      istream& operator>>(istream& is, const Sales_data& item ){
      double price;// 单价
      is >> item.bookNo >> item.units_sold >> price;
      if(is)//检测输入是否成功
        item.revenue = item.units_sold * price
      else
        item = Sales_data();//输入失败，对象呗赋予默认的状态
        return is;
      }
## 重载 关系运算符  ==  不等于也类似 !=
    // 关系运算符  返回类型为 bool  输入两个类对象的 常量 引用 避免拷贝 节省时间 常量限制 避免修改 
    bool 
    operator==(const Sales_item &lhs, const Sales_item &rhs)
    {
        // 在类中被是定义为 friend 有元函数 
        // friend bool operator==(const Sales_item&, const Sales_item&);// 重定向 等于符号 == 
        return lhs.units_sold == rhs.units_sold &&
               lhs.revenue == rhs.revenue &&
               lhs.isbn() == rhs.isbn();
    }
## 整体 浏览

        #ifndef SALESITEM_H
        // we're here only if SALESITEM_H has not yet been defined 
        #define SALESITEM_H

        // Definition of Sales_item class and related functions goes here
        #include <iostream>
        #include <string>

        class Sales_item {
        // these declarations are explained section 7.2.1, p. 270 
        // and in chapter 14, pages 557, 558, 561
        // 操作符 定义
        friend std::istream& operator>>(std::istream&, Sales_item&);// 重定向输入 >> 符号
        friend std::ostream& operator<<(std::ostream&, const Sales_item&);// 重定向输出 << 符号
        friend bool operator<(const Sales_item&, const Sales_item&);// 重定向 小于符号 < 
        friend bool operator==(const Sales_item&, const Sales_item&);// 重定向 等于符号 ==  
        public:
            // constructors are explained in section 7.1.4, pages 262 - 265
            // default constructor needed to initialize members of built-in type
            Sales_item() = default;
            Sales_item(const std::string &book): bookNo(book) { }
            Sales_item(std::istream &is) { is >> *this; }
        public:
            // operations on Sales_item objects
            // member binary operator: left-hand operand bound to implicit this pointer
            Sales_item& operator+=(const Sales_item&);

            // operations on Sales_item objects
            std::string isbn() const { return bookNo; }
            double avg_price() const;
        // private members as before
        private:
            std::string bookNo;      // implicitly initialized to the empty string
            unsigned units_sold = 0; // explicitly initialized
            double revenue = 0.0;
        };

        // used in chapter 10
        inline
        bool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) 
        { return lhs.isbn() == rhs.isbn(); }

        // nonmember binary operator: must declare a parameter for each operand
        Sales_item operator+(const Sales_item&, const Sales_item&);

        inline bool 
        operator==(const Sales_item &lhs, const Sales_item &rhs)
        {
            // must be made a friend of Sales_item
            return lhs.units_sold == rhs.units_sold &&
                   lhs.revenue == rhs.revenue &&
                   lhs.isbn() == rhs.isbn();
        }

        inline bool 
        operator!=(const Sales_item &lhs, const Sales_item &rhs)
        {
            return !(lhs == rhs); // != defined in terms of operator==
        }

        // assumes that both objects refer to the same ISBN
        Sales_item& Sales_item::operator+=(const Sales_item& rhs) 
        {
            units_sold += rhs.units_sold; 
            revenue += rhs.revenue; 
            return *this;
        }

        // assumes that both objects refer to the same ISBN
        Sales_item 
        operator+(const Sales_item& lhs, const Sales_item& rhs) 
        {
            Sales_item ret(lhs);  // copy (|lhs|) into a local object that we'll return
            ret += rhs;           // add in the contents of (|rhs|) 
            return ret;           // return (|ret|) by value
        }

        std::istream& 
        operator>>(std::istream& in, Sales_item& s)
        {
            double price;
            in >> s.bookNo >> s.units_sold >> price;
            // check that the inputs succeeded
            if (in)
                s.revenue = s.units_sold * price;
            else 
                s = Sales_item();  // input failed: reset object to default state
            return in;
        }

        std::ostream& 
        operator<<(std::ostream& out, const Sales_item& s)
        {
            out << s.isbn() << " " << s.units_sold << " "
                << s.revenue << " " << s.avg_price();
            return out;
        }

        double Sales_item::avg_price() const
        {
            if (units_sold) 
                return revenue/units_sold; 
            else 
                return 0;
        }
        #endif
        
# 模板类
      template<class genType>//声明模板类型
      class genClass{
            genType storage[50];//模板类型 数组
            };
      // 定义
      genClass<int>    intObject;   // int 类型数组
      genClass<double> doubleObject;// double 类型数组

      // 其二也可以将 数组大小推迟定义
      template<class genType, int size = 50>// 声明模板类型 书序大小默认为50
      class genClass{
            genType storage[size];//模板类型 数组
            };
      // 定义
      genClass<int>    intObject1;         // int 类型数组 默认   大小
      genClass<int, 100>    intObject2;    // int 类型数组 数组大小为 100 
      genClass<double, 123> doubleObject;  // double 类型数组  数组大小为 123

# 模板函数
      // 交换两个变量的值
      template<class genType>//声明模板类型
      void my_swap(genType& num1, genType& num2){   // 注意为 引用 需要对实参修改
            genType temp = num1;
            num1 = num2;
            num2 = temp;
          }
      
# 类的 继承

      #include <iostream> 
      using namespace std;

      // 基类 
      class BaseClass {
      public://共有类型 哪里都可以访问 
      BaseClass() { }//默认构造函数 
            void f(char *s = "unknown") {
                  cout << "Function f() in BaseClass called from " << s << endl;
                h();//类内可以访问 类的私有函数 
          }

      protected:// 保护类型  子类 和 友元函数/有元类 可以访问 
            void g(char *s = "unknown") {
                  cout << "Function g() in BaseClass called from " << s << endl;
            }

      private:// 类内 和 元函数/有元类 可以访问 
            void h() {
                  cout << "Function h() in BaseClass\n";
            }
      };

      // 子类 Derived1Level1 共有继承自 基类   BaseClass 
      class Derived1Level1 : public virtual BaseClass {
      public:
            void f(char *s = "unknown") {
                  cout << "Function f() in Derived1Level1 called from " << s << endl;
                  g("Derived1Level1");// 本子类没有重写g() 因此调用的是 父类的g() 保护类型可以继承 子类内可以访问 
                  // 函数时调用的基类的 但是参数 还是按子类传入的  
                  h("Derived1Level1");// 本子类重写了h()(本身父类的为私有，子类也调用不了), 因此调用的是 自己的 h() 
            }

            void h(char *s = "unknown") {
                  cout << "Function h() in Derived1Level1 called from " << s << endl;
            }
      };


      class Derived2Level1 : public virtual BaseClass {
      public:
            void f(char *s = "unknown") {
            cout << "Function f() in Derived2Level1 called from " << s << endl;
            g("Derived2Level1");// 调用基类的g() 保护类型的函数  但是参数按 子类传入的参数  
            // h(); // 错误 : h()为基类的 私有函数 ，子类访问不了 BaseClass::h() is not accessible
            }
      };

      //二级继承 
      class DerivedLevel2 : public Derived1Level1, public Derived2Level1 {
      public:
            void f(char *s = "unknown") {
            cout << "Function f() in DerivedLevel2 called from " << s << endl;
            g("DerivedLevel2");// g()函数只有基类有 实现 调用的是基类的 保护继承g() 但是参数是 子类 最新传递的 
            Derived1Level1::h("DerivedLevel2");// 父亲Derived1Level1有h()  爷爷 也有h() 需要指定调用的哪一个  参数都是最新的 
            BaseClass::f("DerivedLevel2");// f()函数  两个父亲 和 一个爷爷都有实现，需要指明调用哪一个  参数都是最新的 
            }
      };


      int main() {
      BaseClass bc;//基类 
      Derived1Level1 d1l1;//子类1 
      Derived2Level1 d2l1;//子类2 
      DerivedLevel2 dl2;//子类的子类 

      bc.f("main(1)");// 
      // bc.g(); // 错误: 保护类型 类外访问不了 BaseClass::g() is not accessible
      // bc.h(); // 错误: 私有类型 类外访问不了 BaseClass::h() is not accessible
      cout << "---------------"<< endl; 

      d1l1.f("main(2)");//首先调用子类重写的 f() 
      // 内部调用了 基类的g()(函数时调用的基类的 但是参数 还是按子类传入的 ) 和 自身重写的 h() 
      // d1l1.g(); // 错误: 在子类内 可以访问父类的保护类型函数g(), 外面访问不了 BaseClass::g() is not accessible


      d1l1.h("main(3)");// 调用子类自己重写的函数 参数按最新传入的 

      d2l1.f("main(4)");// 调用子类的函数f(),内部调用了父类的b保护类型函数g() 但是参数按子类传入的参数 
      // d2l1.g(); // 父类的保护函数g() 在子类内可以访问 ，外部访问不了 错误 BaseClass::g() is not accessible
      // d2l1.h(); // 父类的私有函数 子类内，外部都访问不了 错误: BaseClass::h() is not accessible


      dl2.f("main(5)");//类自身f() 内部 爷爷的 g() 父亲1的 h() 爷爷的  f()  参数都是最新传入的 
      // dl2.g(); // error: BaseClass::g() is not accessible

      dl2.h();//外部能访问 父亲  Derived1Level1的 共有类型函数 h() 
      return 0;
      }
      /*
      Function f() in BaseClass called from main(1)
      Function h() in BaseClass
      Function f() in Derived1Level1 called from main(2)
      Function g() in BaseClass called from Derived1Level1
      Function h() in Derived1Level1 called from Derived1Level1
      Function h() in Derived1Level1 called from main(3)
      Function f() in Derived2Level1 called from main(4)
      Function g() in BaseClass called from Derived2Level1
      Function f() in DerivedLevel2 called from main(5)
      Function g() in BaseClass called from DerivedLevel2
      Function h() in Derived1Level1 called from DerivedLevel2
      Function f() in BaseClass called from DerivedLevel2
      Function h() in BaseClass
      Function h() in Derived1Level1 called from unknown

      --------------------------------
      Process exited with return value 0
      Press any key to continue . . .

      */ 
